Clio.Component.Util.Metadata
====

Clio Metadataコンポーネントは、"スキーマ"または"設計定義"と呼ばれるものです。

## 構成

Metadataコンポーネントは、以下の３つの大きな構成に分割することができます。

  - メタデータ
  - マッピング
  - タイプ
  
### メタデータ
メタデータは、大きく２つに分けることができます。

  - スキーマメタデータ
  - フィールドメタデータ
  
スキーマメタデータは、クラスや配列といった、１つの利用単位です。  
多くの場合、クラスメタデータを利用するかと思います。

一方、フィールドメタデータは、上記のスキーマメタデータを構成するフィールドの定義です。
そのフィールドの型(Type)などを保持します。


上記、スキーマおよびフィールドメタデータは、そのクラスインスタンスなどにアクセスする際に有効に用いることが可能です。  
しかし、デフォルトのメタデータは、保持する情報があまりにも不足しています。 
そこで、次のマッピングが用いられます。

### マッピング
マッピングとは、上記の「メタデータに付与することができる情報」です。  
実際には、「利用時の意味合いに応じた単位」でメタデータに「情報を付与」します。

例えば、identifierというマッピングは、そのクラスのidentifierがどのフィールドで構成されているかを保持するマッピング情報です。

多くの場合、Metadataは、スキーマまたはフィールドの存在を示すものであり、Mappingが具体的な情報を保持します。

### タイプ
タイプは、Metadataコンポーネントを構成する最後の要素です。 
タイプの利用シーンは２つあります。

  - フィールドの型を表す(FieldType)
  - 型に沿った情報を取得する
  
フィールドメタデータは、デフォルトでは、Mixedな型です  
しかし、例えば、アノテーションなどにより`@var int`と示された場合、そのフィールドは、"`int`として扱う"べきです。
このように、フィールドをどのように扱うべきかを示すために、型は存在します。

また、例えば、シリアライゼーションを考えてみてください。
`$variable`を`int`として、シリアライゼーションしたい場合も存在するかもしれません。
同様に、`$variable`を`Class\You\Defined`としてシリアライゼーションしたい場合もあるでしょう。

このような場合、Type `Class\You\Defined`は、どのように扱われるべきでしょうか？
この`$variable`を正常にシリアライゼーションするためには、Defined.propertiesなどの定義を再帰的に読み込む必要があります。

### 関連性
このように、メタデータはマッピングを持ち、スキーマメタデータはフィールドメタデータを持ち、フィールドメタデータはタイプを持ち、そして、タイプは場合に応じスキーマメタデータを参照します。

これらの依存性を遅延的に挿入するために、２つの主クラスが用意されています。

  - TypeRegistry
  - SchemaRegistry
  
